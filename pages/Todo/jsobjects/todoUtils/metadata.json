{
  "pluginType": "JS",
  "pluginId": "js-plugin",
  "unpublishedAction": {
    "name": "todoUtils",
    "fullyQualifiedName": "todoUtils",
    "datasource": {
      "name": "UNUSED_DATASOURCE",
      "pluginId": "js-plugin",
      "messages": [],
      "isAutoGenerated": false,
      "id": "UNUSED_DATASOURCE",
      "deleted": false,
      "policies": [],
      "userPermissions": []
    },
    "pageId": "Todo",
    "actionConfiguration": {
      "timeoutInMillisecond": 10000,
      "paginationType": "NONE",
      "encodeParamsToggle": true,
      "body": "export default {\n  // Get all tasks from the database\n  getAllTasks: async () => {\n    const tasks = await getAllTasks.run();\n    // Sort tasks with incomplete tasks first, then by creation date (newest first)\n    return tasks.sort((a, b) => {\n      if (a.is_complete !== b.is_complete) {\n        return a.is_complete ? 1 : -1; // Incomplete tasks first\n      }\n      // If completion status is the same, sort by creation date (newest first)\n      return new Date(b.created_at) - new Date(a.created_at);\n    });\n  },\n  \n  // Add a new task\n  addTask: async () => {\n    // Check if task title is empty\n    if (!Input_TaskTitle.text || Input_TaskTitle.text.trim() === \"\") {\n      showAlert(\"Task title cannot be empty\", \"error\");\n      return;\n    }\n    \n    // Generate a unique ID for the new task\n    const id = Math.floor(Math.random() * 1000000);\n    \n    // Create the task\n    await createTask.run({\n      id: id\n    });\n    \n    // Clear the input field\n    Input_TaskTitle.setValue(\"\");\n    \n    // Refresh the task list\n    await List_Tasks.setData(await this.getAllTasks());\n    \n    // Show success message\n    showAlert(\"Task added successfully\", \"success\");\n  },\n  \n  // Toggle task completion status\n  toggleComplete: async (taskId, currentStatus) => {\n    // Set the selected task\n    storeValue(\"selectedTask\", { id: taskId, is_complete: currentStatus });\n    \n    // Update the task completion status\n    await updateTaskIsComplete.run();\n    \n    // Refresh the task list\n    await List_Tasks.setData(await this.getAllTasks());\n    \n    // Show success message\n    showAlert(\"Task updated\", \"success\");\n  },\n  \n  // Delete a task\n  deleteTask: async (taskId) => {\n    // Store the task ID for deletion\n    storeValue(\"selectedTask\", { id: taskId });\n    \n    // Show the confirmation modal\n    showModal(\"Modal_ConfirmDelete\");\n  }\n}",
      "jsArguments": [],
      "isAsync": true
    },
    "executeOnLoad": true,
    "dynamicBindingPathList": [
      {
        "key": "body"
      }
    ],
    "isValid": true,
    "invalids": [],
    "messages": [],
    "jsonPathKeys": [
      "Input_TaskTitle.setValue(\"\")",
      "Input_TaskTitle.text",
      "Input_TaskTitle.text.trim() === \"\"",
      "List_Tasks.setData(await this.getAllTasks())",
      "Math.floor(Math.random() * 1000000)",
      "await List_Tasks.setData(await this.getAllTasks())",
      "await createTask.run({\n      id: id\n    })",
      "await getAllTasks.run()",
      "await this.getAllTasks()",
      "await updateTaskIsComplete.run()",
      "new Date(b.created_at) - new Date(a.created_at)",
      "showAlert(\"Task added successfully\", \"success\")",
      "showAlert(\"Task title cannot be empty\", \"error\")",
      "showAlert(\"Task updated\", \"success\")",
      "showModal(\"Modal_ConfirmDelete\")",
      "storeValue(\"selectedTask\", { id: taskId })",
      "storeValue(\"selectedTask\", { id: taskId, is_complete: currentStatus })",
      "tasks.sort((a, b) => {\n      if (a.is_complete !== b.is_complete) {\n        return a.is_complete ? 1 : -1; // Incomplete tasks first\n      }\n      // If completion status is the same, sort by creation date (newest first)\n      return new Date(b.created_at) - new Date(a.created_at);\n    })"
    ],
    "userSetOnLoad": true,
    "confirmBeforeExecute": false,
    "policies": [],
    "userPermissions": []
  },
  "id": "Todo_todoUtils",
  "deleted": false,
  "gitSyncId": "Todo_todoUtils"
}